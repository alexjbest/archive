---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Subtypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html">Subtypes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196071923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196071923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196071923">(May 02 2020 at 21:57)</a>:</h4>
<p>How does one create subtypes? Say I want a function  of two parameters one is an arbitrary natural number, the other is a natural number &lt; 100.</p>



<a name="196072236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072236">(May 02 2020 at 22:07)</a>:</h4>
<p>In this case I would just use <code>fin</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">100</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>In general, <code>{a // P a}</code> where <code>α : Type</code> and <code>P : α → Prop</code> is notation for the subtype of terms of type <code>α</code> that satisfy <code>P</code>. Subtypes are mentioned briefly in TPiL <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">in chapter 7</a>. See also <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic" title="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic">this mathlib doc page</a>.</p>



<a name="196072433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072433">(May 02 2020 at 22:13)</a>:</h4>
<p>Thanks!</p>



<a name="196072434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072434">(May 02 2020 at 22:13)</a>:</h4>
<p>Why doesn't this work?</p>



<a name="196072437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072437">(May 02 2020 at 22:13)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">4</span> <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">100</span><span class="o">}</span> <span class="o">:=</span> <span class="mi">4</span> <span class="c1">--error</span>
</code></pre></div>



<a name="196072649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072649">(May 02 2020 at 22:20)</a>:</h4>
<p>Because <code>4</code> is not a term of that subtype. You can construct a term like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">100</span><span class="o">}</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">4</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="bp">⟩</span>
<span class="c1">-- dec_trivial also works and doesn&#39;t require any import</span>
</code></pre></div>



<a name="196072787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072787">(May 02 2020 at 22:24)</a>:</h4>
<p>But <code>example : fin 100 := 4</code> works</p>



<a name="196073091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196073091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196073091">(May 02 2020 at 22:33)</a>:</h4>
<p>That's because <code>4</code> is a term of type <code>fin 100</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">numerals</span> <span class="n">false</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">100</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">bit0 (bit0 has_one.one) : fin (bit0 (bit0 (bit1 (bit0 (bit0 (bit1 has_one.one))))))</span>
<span class="cm">-/</span>
</code></pre></div>


<p>See <a href="https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56" title="https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56">here</a>. Note how Lean interprets numerals in terms of <code>bit0</code>, <code>bit1</code> and <code>has_one.one</code> and <code>has_zero.zero</code>.</p>



<a name="196074984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196074984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196074984">(May 02 2020 at 23:30)</a>:</h4>
<p>Just because the thing you defined, <code>{n : ℕ // n ≤ 100}</code> is "pretty much exactly the same thing as" <code>fin 100</code>, doesn't mean that everything that works for <code>fin 100</code> will work for <code>{n : ℕ // n ≤ 100}</code>. There are lots of extra definitions which have been put on top of <code>fin n</code>, e.g. it has a 0, a 1, an add, and so on. If you want the same for your type you'll have to give it a name and put all these structure on it yourself.</p>



{% endraw %}

<hr><p>Last updated: May 03 2020 at 00:08 UTC</p>