---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Subtypes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html">Subtypes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196071923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196071923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196071923">(May 02 2020 at 21:57)</a>:</h4>
<p>How does one create subtypes? Say I want a function  of two parameters one is an arbitrary natural number, the other is a natural number &lt; 100.</p>



<a name="196072236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072236">(May 02 2020 at 22:07)</a>:</h4>
<p>In this case I would just use <code>fin</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">100</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>In general, <code>{a // P a}</code> where <code>α : Type</code> and <code>P : α → Prop</code> is notation for the subtype of terms of type <code>α</code> that satisfy <code>P</code>. Subtypes are mentioned briefly in TPiL <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">in chapter 7</a>. See also <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic" title="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic">this mathlib doc page</a>.</p>



<a name="196072433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072433">(May 02 2020 at 22:13)</a>:</h4>
<p>Thanks!</p>



<a name="196072434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072434">(May 02 2020 at 22:13)</a>:</h4>
<p>Why doesn't this work?</p>



<a name="196072437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072437">(May 02 2020 at 22:13)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">4</span> <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">100</span><span class="o">}</span> <span class="o">:=</span> <span class="mi">4</span> <span class="c1">--error</span>
</code></pre></div>



<a name="196072649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072649">(May 02 2020 at 22:20)</a>:</h4>
<p>Because <code>4</code> is not a term of that subtype. You can construct a term like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">≤</span> <span class="mi">100</span><span class="o">}</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">4</span><span class="o">,</span> <span class="k">by</span> <span class="n">norm_num</span><span class="bp">⟩</span>
<span class="c1">-- dec_trivial also works and doesn&#39;t require any import</span>
</code></pre></div>



<a name="196072787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196072787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196072787">(May 02 2020 at 22:24)</a>:</h4>
<p>But <code>example : fin 100 := 4</code> works</p>



<a name="196073091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196073091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196073091">(May 02 2020 at 22:33)</a>:</h4>
<p>That's because <code>4</code> is a term of type <code>fin 100</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">numerals</span> <span class="n">false</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">100</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">bit0 (bit0 has_one.one) : fin (bit0 (bit0 (bit1 (bit0 (bit0 (bit1 has_one.one))))))</span>
<span class="cm">-/</span>
</code></pre></div>


<p>See <a href="https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56" title="https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56">here</a>. Note how Lean interprets numerals in terms of <code>bit0</code>, <code>bit1</code> and <code>has_one.one</code> and <code>has_zero.zero</code>.</p>



<a name="196074984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196074984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196074984">(May 02 2020 at 23:30)</a>:</h4>
<p>Just because the thing you defined, <code>{n : ℕ // n ≤ 100}</code> is "pretty much exactly the same thing as" <code>fin 100</code>, doesn't mean that everything that works for <code>fin 100</code> will work for <code>{n : ℕ // n ≤ 100}</code>. There are lots of extra definitions which have been put on top of <code>fin n</code>, e.g. it has a 0, a 1, an add, and so on. If you want the same for your type you'll have to give it a name and put all these structure on it yourself.</p>



<a name="196076427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196076427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196076427">(May 03 2020 at 00:15)</a>:</h4>
<p>Deleted</p>



<a name="196078391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196078391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196078391">(May 03 2020 at 01:14)</a>:</h4>
<p>I want to implement a function that adds two lists of the same length element-wise, but I don't know how to make sure the lists are the same size. Should I instead return an <code>option list</code> so that if they're the same size (using <code>if..then..else</code>) then I can do some computation and return <code>some list</code> otherwise <code>none</code> ?</p>



<a name="196081150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081150">(May 03 2020 at 02:44)</a>:</h4>
<p>If you want lists of fixed length, you could use vectors :P<br>
If you're doing it with lists, you probably want something like </p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">length_eq</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="196081359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081359">(May 03 2020 at 02:51)</a>:</h4>
<p>If you want to define it for vectors, it'd look something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="n">def</span> <span class="n">add_vecs</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="196081415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081415">(May 03 2020 at 02:53)</a>:</h4>
<p>Yeah I should do this with vectors I don't know why I'm using lists</p>



<a name="196081530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081530">(May 03 2020 at 02:56)</a>:</h4>
<p>Although if you want to define your function by pattern matching/recursion, it may be a bit more complicated than by just using lists.</p>



<a name="196081658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081658">(May 03 2020 at 03:01)</a>:</h4>
<p>and when you try to call the function,  <code>vector</code>s is not as nice to use compared to <code>list</code>s.</p>



<a name="196081698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Subtypes/near/196081698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Subtypes.html#196081698">(May 03 2020 at 03:02)</a>:</h4>
<p>Actually this works pretty well even for non-equal lists. </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">list_add</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="n">l2</span> <span class="o">:=</span> <span class="n">l2</span>
<span class="bp">|</span> <span class="n">l1</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="o">:=</span> <span class="n">l1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span> <span class="bp">::</span> <span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="bp">::</span> <span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1</span> <span class="bp">+</span> <span class="n">h2</span><span class="o">)</span> <span class="bp">::</span> <span class="o">(</span><span class="n">list_add</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">list_add</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="c1">-- [10, 3]</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">list_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1">-- [3, 6, 3]</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: May 03 2020 at 03:08 UTC</p>