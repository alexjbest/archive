---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html">pow_(left|right)_inj(ective)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197104653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197104653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197104653">(May 11 2020 at 06:31)</a>:</h4>
<p>In <code>algebra.group_power</code>, there is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">pow_right_inj</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">Hxpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">Hypos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">Hnpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hxyn</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
</code></pre></div>


<p>In <code>data.nat.basic</code>, there is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">pow_left_injective</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">x</span><span class="bp">^</span><span class="n">m</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">pow_right_injective</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">pow</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>Am I being stupid, or are the terms <code>left</code> and <code>right</code> used in opposite ways here?</p>



<a name="197104913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197104913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197104913">(May 11 2020 at 06:34)</a>:</h4>
<p>This happens sometimes. You can try to look at other lemmas with <code>left</code>/<code>right</code> and <code>inj</code> in their names, decide which convention is used in more cases, and PR a fix.</p>



<a name="197104956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197104956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197104956">(May 11 2020 at 06:35)</a>:</h4>
<p>Will do, thanks.</p>



<a name="197104958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197104958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197104958">(May 11 2020 at 06:35)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/inf_le_inf_left" title="#narrow/stream/113488-general/topic/inf_le_inf_left">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inf_le_inf_left</a></p>



<a name="197105047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197105047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197105047">(May 11 2020 at 06:37)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="gp">$</span> git grep <span class="s1">&#39;\(lemma\|theorem\) *[^ ]*\(left\|right\)[^ ]*inj&#39;</span>
<span class="go">docs/contribute/style.md:theorem add_right_inj {n m k : nat} : n + m = n + k → m = k :=</span>
<span class="go">src/algebra/group/basic.lean:theorem mul_left_injective [left_cancel_semigroup M] (a : M) : function.injective ((*) a) :=</span>
<span class="go">src/algebra/group/basic.lean:theorem mul_right_injective [right_cancel_semigroup M] (a : M) : function.injective (λ x, x * a) :=</span>
<span class="go">src/algebra/group/basic.lean:theorem mul_left_inj [left_cancel_semigroup M] (a : M) {b c : M} : a * b = a * c ↔ b = c :=</span>
<span class="go">src/algebra/group/basic.lean:theorem mul_right_inj [right_cancel_semigroup M] (a : M) {b c : M} : b * a = c * a ↔ b = c :=</span>
<span class="go">src/algebra/group/basic.lean:@[simp] lemma sub_left_inj : a - b = a - c ↔ b = c :=</span>
<span class="go">src/algebra/group/basic.lean:@[simp] lemma sub_right_inj : b - a = c - a ↔ b = c :=</span>
<span class="go">src/algebra/group/units.lean:@[simp, to_additive] theorem mul_left_inj (a : units α) {b c : α} : (a:α) * b = a * c ↔ b = c :=</span>
<span class="go">src/algebra/group/units.lean:@[simp, to_additive] theorem mul_right_inj (a : units α) {b c : α} : b * a = c * a ↔ b = c :=</span>
<span class="go">src/algebra/group/units.lean:  @[simp] theorem divp_right_inj (u : units α) {a b : α} : a /ₚ u = b /ₚ u ↔ a = b :=</span>
<span class="go">src/algebra/group_power.lean:theorem pow_right_inj {x y : R} {n : ℕ} (Hxpos : 0 ≤ x) (Hypos : 0 ≤ y) (Hnpos : 0 &lt; n)</span>
<span class="go">src/algebra/group_with_zero.lean:lemma div_right_inj&#39; (hc : c ≠ 0) : a / c = b / c ↔ a = b :=</span>
<span class="go">src/algebra/group_with_zero.lean:lemma mul_right_inj&#39; (hc : c ≠ 0) : a * c = b * c ↔ a = b :=</span>
<span class="go">src/algebra/ring.lean:  theorem domain.mul_right_inj {a b c : α} (ha : a ≠ 0) : b * a = c * a ↔ b = c :=</span>
<span class="go">src/algebra/ring.lean:  theorem domain.mul_left_inj {a b c : α} (ha : a ≠ 0) : a * b = a * c ↔ b = c :=</span>
<span class="go">src/data/finsupp.lean:lemma single_right_inj (h : b ≠ 0) :</span>
<span class="go">src/data/list/basic.lean:theorem append_left_inj {t₁ t₂ : list α} (s) : s ++ t₁ = s ++ t₂ ↔ t₁ = t₂ :=</span>
<span class="go">src/data/list/basic.lean:theorem append_right_inj {s₁ s₂ : list α} (t) : s₁ ++ t = s₂ ++ t ↔ s₁ = s₂ :=</span>
<span class="go">src/data/list/basic.lean:theorem prefix_append_left_inj {l₁ l₂ : list α} (l) : l ++ l₁ &lt;+: l ++ l₂ ↔ l₁ &lt;+: l₂ :=</span>
<span class="go">src/data/nat/basic.lean:protected theorem mul_right_inj {a b c : ℕ} (ha : 0 &lt; a) : b * a = c * a ↔ b = c :=</span>
<span class="go">src/data/nat/basic.lean:protected theorem mul_left_inj {a b c : ℕ} (ha : 0 &lt; a) : a * b = a * c ↔ b = c :=</span>
<span class="go">src/data/nat/basic.lean:lemma pow_right_injective {x : ℕ} (k : 2 ≤ x) : function.injective (nat.pow x) :=</span>
<span class="go">src/data/nat/basic.lean:lemma pow_left_injective {m : ℕ} (k : 1 ≤ m) : function.injective (λ (x : ℕ), x^m) :=</span>
<span class="go">src/data/real/ennreal.lean:lemma add_left_inj (h : a &lt; ∞) : a + b = a + c ↔ b = c :=</span>
<span class="go">src/data/real/ennreal.lean:lemma add_right_inj (h : a &lt; ∞) : b + a = c + a ↔ b = c :=</span>
<span class="go">src/data/real/ennreal.lean:lemma sub_left_inj {a b c : ennreal} (ha : a &lt; ⊤) (hb : b ≤ a) (hc : c ≤ a) :</span>
<span class="go">src/data/set/function.lean:theorem left_inv_on.inj_on (h : left_inv_on f₁&#39; f s) : inj_on f s :=</span>
<span class="go">src/linear_algebra/basis.lean:lemma exists_left_inverse_linear_map_of_injective {f : V →ₗ[K] V&#39;}</span>
<span class="go">src/set_theory/ordinal.lean:theorem mul_left_inj {a b c : ordinal} (a0 : 0 &lt; a) : a * b = a * c ↔ b = c :=</span>
<span class="go">src/set_theory/ordinal.lean:theorem power_right_inj {a b c : ordinal}</span>
<span class="gp">$</span> git grep <span class="s1">&#39;\(lemma\|theorem\) *[^ ]*inj[^ ]*\(left\|right\)&#39;</span>
<span class="go">src/data/list/basic.lean:theorem append_inj_left {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length s₁ = length s₂) : t₁ = t₂ :=</span>
<span class="go">src/data/list/basic.lean:theorem append_inj_right {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length s₁ = length s₂) : s₁ = s₂ :=</span>
<span class="go">src/data/list/basic.lean:theorem append_inj_left&#39; {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) : t₁ = t₂ :=</span>
<span class="go">src/data/list/basic.lean:theorem append_inj_right&#39; {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) : s₁ = s₂ :=</span>
<span class="go">src/data/multiset.lean:@[simp] theorem cons_inj_left {a b : α} (s : multiset α) :</span>
<span class="go">src/data/multiset.lean:@[simp] theorem cons_inj_right (a : α) : ∀{s t : multiset α}, a::s = a::t ↔ s = t :=</span>
<span class="go">src/data/set/function.lean:theorem inj_on.right_inv_on_of_left_inv_on (hf : inj_on f s) (hf&#39; : left_inv_on f f&#39; t)</span>
<span class="go">src/data/set/function.lean:theorem inj_on.left_inv_on_inv_fun_on [nonempty α] (h : inj_on f s) :</span>
<span class="go">src/logic/function.lean:theorem injective_of_partial_inv_right {α β} {f : α → β} {g} (H : is_partial_inv f g)</span>
<span class="go">src/logic/function.lean:theorem inv_fun_eq_of_injective_of_right_inverse {g : β → α}</span>
<span class="go">src/logic/function.lean:lemma injective.has_left_inverse (hf : injective f) : has_left_inverse f :=</span>
<span class="go">src/logic/function.lean:lemma injective_iff_has_left_inverse : injective f ↔ has_left_inverse f :=</span>
</code></pre></div>



<a name="197112681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197112681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197112681">(May 11 2020 at 08:06)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/2652">#2652</a></p>



<a name="197117954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197117954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197117954">(May 11 2020 at 09:01)</a>:</h4>
<p>I'm surprised that the convention used in that PR is more popular. I would have used the other way around.</p>



<a name="197118701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197118701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197118701">(May 11 2020 at 09:12)</a>:</h4>
<p>I would concur with Chris here. I think that in an injectivity lemma you should name the variable that changes, not the variable that doesn't. (Consider how it would generalize to theorems like <code>f a b c d = f a b c' d -&gt; c = c'</code>.)</p>



<a name="197118936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197118936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197118936">(May 11 2020 at 09:15)</a>:</h4>
<p>that's why the left/right convention is arbitrary and entirely inconsistent</p>



<a name="197118969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197118969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197118969">(May 11 2020 at 09:15)</a>:</h4>
<p>In maths I never know what a left module is and a right module. I never know what a left adjoint and a right adjoint functor are either, and all attempts to "explain" this to me have been ultimately futile. I don't even know which to use out of <code>congr_arg</code> and <code>congr_fun</code>. One fixes the arg and changes the fun, and the other does the other one. I just look these things up when I need to know.</p>



<a name="197120168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120168">(May 11 2020 at 09:29)</a>:</h4>
<p>With a congr lemma do you name the variable that changes or the variable that doesn't? With a left module is it the ring element on the left or the module element? Is it possible to make some sort of global convention or are all of these slightly different questions each worthy of conventions which have to be individually learnt?</p>



<a name="197120232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120232">(May 11 2020 at 09:30)</a>:</h4>
<p>with <code>congr_arg</code> and <code>congr_fun</code>, the named thing is the thing that changes</p>



<a name="197120248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120248">(May 11 2020 at 09:30)</a>:</h4>
<p>Now tell me how to remember that</p>



<a name="197120305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120305">(May 11 2020 at 09:31)</a>:</h4>
<p>Because this is an arbitrary decision</p>



<a name="197120316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120316">(May 11 2020 at 09:31)</a>:</h4>
<p>I think the multiple arguments thing is a good example. If you have a seven argument function and you need to change one of them, you want to name the thing that is changing</p>



<a name="197120383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120383">(May 11 2020 at 09:32)</a>:</h4>
<p>i.e. <code>f_inj_third_arg</code> or something</p>



<a name="197120420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120420">(May 11 2020 at 09:32)</a>:</h4>
<p>Can this be translated into a convention for a=b iff a+c = b+c? Is the left argument "changing"there in the sense that it could be two things?</p>



<a name="197120470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120470">(May 11 2020 at 09:33)</a>:</h4>
<p>This is injectivity of <code>\lam x, x + c</code>. Spot the variable</p>



<a name="197120484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120484">(May 11 2020 at 09:33)</a>:</h4>
<p>This is something I've struggled with all my life and I'd love to see some sort of global "principle" which guides conventions so I get better at guessing</p>



<a name="197120529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197120529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197120529">(May 11 2020 at 09:34)</a>:</h4>
<p>If you have <code>\lam x, bla bla .... x ... bla bla</code> you name where the <code>x</code> is</p>



<a name="197121855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197121855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197121855">(May 11 2020 at 09:47)</a>:</h4>
<p>One reason why the other convention is so popular might be that lemmas like <code>mul_left_injective</code> are really just synonyms for lemmas like <code>mul_left_cancel</code>, which follow the other convention. Still, I agree that the convention where the name refers to the variable makes more sense and will make another PR.</p>



<a name="197122423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197122423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197122423">(May 11 2020 at 09:52)</a>:</h4>
<p><code>mul_left_cancel</code> makes some sense given that it says in the name that the thing on the left is being cancelled</p>



<a name="197122435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197122435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197122435">(May 11 2020 at 09:52)</a>:</h4>
<p>it also agrees with wikipedia</p>



<a name="197122524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197122524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197122524">(May 11 2020 at 09:53)</a>:</h4>
<p>I agree. I just meant that when defining a synonym for <code>mul_left_cancel</code> (which is a good name), it might be tempting to name it <code>mul_left_injective</code>, even though <code>mul_right_injective</code> makes more sense</p>



<a name="197132864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pow_%28left%7Cright%29_inj%28ective%29/near/197132864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/pow_(left.7Cright)_inj(ective).html#197132864">(May 11 2020 at 11:43)</a>:</h4>
<p>I struggled with the <code>left</code>/<code>right</code> conventions in the early days of Lean, when working on the libraries for Lean 0.1 and Lean 2. I apologize if some of the inconsistencies go back to me. I remember trying to adopt a convention that in a name like <code>nat.dvd_of_mul_dvd_mul_right</code>, the new thing was being multiplied on the right, so the theorem has something to do with replacing <code>x</code> by <code>x * k</code>. (So now can you guess what the theorem says?)</p>
<p>I see that <code>left</code> and <code>right</code> are mentioned lots of times in our naming conventions: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md">https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md</a>, but we don't say anything about how to use them. It might help if someone tries to establish a consistent convention, but, in practice, it doesn't make a difference. It is hard to remember and think through the conventions anyhow, so users will generally use tab completion and choose the one they want.</p>



{% endraw %}

<hr><p>Last updated: May 11 2020 at 13:09 UTC</p>