---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html">Modelling a Type Theory in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="195563859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195563859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195563859">(Apr 28 2020 at 13:30)</a>:</h4>
<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">One</span>
<span class="kn">infix</span> <span class="bp">`××`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="mi">101</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
</code></pre></div>


<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>
<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>



<a name="195564055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564055">(Apr 28 2020 at 13:31)</a>:</h4>
<p>I guess what I would like to be able to say is that a variable can be any term, and it's really only defined by its number, and when we bind it to a binder, it then has an associated type.</p>



<a name="195564501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564501">(Apr 28 2020 at 13:34)</a>:</h4>
<blockquote>
<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an all A φ expression if φ has only var 0 A and no var 0 B).</p>
</blockquote>
<p>You can, but it's a pain because you are still in the middle of the definition so you can't easily use recursive functions at the same time</p>



<a name="195564583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195564583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195564583">(Apr 28 2020 at 13:34)</a>:</h4>
<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>



<a name="195565429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195565429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195565429">(Apr 28 2020 at 13:41)</a>:</h4>
<p>Hmm okay I'll take your advice. I was looking at flypitch documentation and they seem to do without a well-formedness predicate. Is that just because their terms are all the same type?</p>



<a name="195565908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195565908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195565908">(Apr 28 2020 at 13:45)</a>:</h4>
<p>It's easier for them because it's only one type, yes. You end up having to carry around a lot of "type state" in real type theories, and it becomes hard to get all the definitional equalities you want</p>



<a name="195566085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195566085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195566085">(Apr 28 2020 at 13:46)</a>:</h4>
<p>But they have a clearly distinct step for proofs, which I think should be the analogue of type checking for you</p>



<a name="195566880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195566880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195566880">(Apr 28 2020 at 13:52)</a>:</h4>
<p>Sorry what step are you referring to?</p>



<a name="195567152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567152">(Apr 28 2020 at 13:54)</a>:</h4>
<p>step in the construction</p>



<a name="195567199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567199">(Apr 28 2020 at 13:54)</a>:</h4>
<p>I would separate the grammar from the syntax rules</p>



<a name="195567247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567247">(Apr 28 2020 at 13:55)</a>:</h4>
<p>If you want terms that embed typing information, so that only well-typed terms can be constructed, the usual approach is to index it not only by a type, but also by a context containing the types of free variables. Thus, you would have something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="bp">|</span> <span class="n">Fun</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">type</span>

<span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var0</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">var</span> <span class="o">[</span><span class="n">α</span><span class="o">]</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">varsucc</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">var</span> <span class="o">(</span><span class="n">β</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">β</span>

<span class="c1">-- This is the simply-typed lambda calculus with a unit type and products.</span>
<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">lam</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">α</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">Fun</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">unit</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">One</span>
</code></pre></div>


<p>This approach works fine and makes the development a little easier if (a) you don't have dependencies in your types (but I guess your <code>all</code> and <code>ex</code> are supposed to be quantifiers?) and (b) Lean properly supports indexed families (which I don't know). Mario's suggested approach -- keeping the syntax simple and putting a type predicate on top -- requires some additional boilerplate, but has the distinct advantage that it'll work regardless of what object theory you want to encode.</p>



<a name="195567396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567396">(Apr 28 2020 at 13:56)</a>:</h4>
<p>Lean's support for indexed families is fine</p>



<a name="195567406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567406">(Apr 28 2020 at 13:56)</a>:</h4>
<p>mutual is not fine</p>



<a name="195567538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195567538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195567538">(Apr 28 2020 at 13:57)</a>:</h4>
<p>While I agree with you up to a point, I find that once you get down to proving theorems about these terms, you might want to e.g. prove something by induction on the context from the other end, and then it enters DTT hell</p>



<a name="195568076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568076">(Apr 28 2020 at 14:01)</a>:</h4>
<p>Yeah I'm a little turned off by the fact that my sequents will also have a context, and I'd have to marry them properly.</p>



<a name="195568381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568381">(Apr 28 2020 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I can see how that proof might be tricky. I've also become more skeptical of intrinsically typed syntax lately -- it's nice when it works, but when it breaks, it sure breaks.</p>



<a name="195568805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568805">(Apr 28 2020 at 14:06)</a>:</h4>
<p><span class="user-mention" data-user-id="255481">@Billy Price</span> I don't know exactly what your sequents look like, but you will probably have two contexts, one for the types and one for the hypotheses (as is customary in HOL)</p>



<a name="195568843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195568843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195568843">(Apr 28 2020 at 14:06)</a>:</h4>
<p>the hypotheses are nondependent so it's not such a big deal</p>



<a name="195569469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195569469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195569469">(Apr 28 2020 at 14:11)</a>:</h4>
<p>The hypotheses in my sequents are just a single <code>term Ω</code>.</p>



<a name="195574629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195574629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195574629">(Apr 28 2020 at 14:46)</a>:</h4>
<p>I'm having a little trouble stating the well-foundedness condition - am I on the right track?</p>
<p>It also seems like there's two level's of well-foundedness - that every bound variable has the correct type, and that any free variables can be bound to a single type.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">v</span><span class="bp">=</span><span class="n">n</span> <span class="bp">∧</span> <span class="n">Z</span><span class="bp">=</span><span class="n">A</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">φ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="err">⁎</span>          <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="n">top</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="n">bot</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">v</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">FV_have_type</span> <span class="n">v</span> <span class="n">q</span>

<span class="n">def</span> <span class="n">well_formed</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">term</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="195574849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195574849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195574849">(Apr 28 2020 at 14:48)</a>:</h4>
<p>Do you mean <code>v = n -&gt; Z = A</code>? in other words saying that all occurrences of variable <code>n</code> are used at type <code>Z</code>?</p>



<a name="195575132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195575132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195575132">(Apr 28 2020 at 14:50)</a>:</h4>
<p>Ah yes</p>



<a name="195576900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195576900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195576900">(Apr 28 2020 at 15:02)</a>:</h4>
<p>I think it isn't the traditional presentation, but I'm pretty sure it is better to only have the notion "<code>φ : term A</code> is well-formed in <code>Γ : context</code>"</p>



<a name="195577003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195577003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195577003">(Apr 28 2020 at 15:03)</a>:</h4>
<p>rather than having only <code>term</code>s with no context and trying to guess the free variables and their types by inspecting the term</p>



<a name="195665323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195665323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195665323">(Apr 29 2020 at 06:24)</a>:</h4>
<p>I started working on a calculus of constructions in Lean à few weeks ago, maybe you find it helpful: <a href="https://github.com/anfelor/coc-lean" title="https://github.com/anfelor/coc-lean">https://github.com/anfelor/coc-lean</a> Feel free to contact me if you have any questions.</p>



<a name="195698879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195698879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195698879">(Apr 29 2020 at 12:14)</a>:</h4>
<p>Awesome! thanks I'll take a look</p>



<a name="195709049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709049">(Apr 29 2020 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> WF means the types of the free variables of <code>term A</code> match the context.</p>



<a name="195709072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709072">(Apr 29 2020 at 13:34)</a>:</h4>
<p>More specifically?</p>



<a name="195709096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709096">(Apr 29 2020 at 13:34)</a>:</h4>
<p>What is the English translation of what you wrote?</p>



<a name="195709139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709139">(Apr 29 2020 at 13:34)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">WF</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kn">context</span> <span class="bp">→</span>  <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
</code></pre></div>



<a name="195709173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709173">(Apr 29 2020 at 13:35)</a>:</h4>
<p>Hang on let me paste my term definition</p>



<a name="195709219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709219">(Apr 29 2020 at 13:35)</a>:</h4>
<p>Also that WF definition is incomplete, there are more terms but they are less interesting to WF</p>



<a name="195709304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709304">(Apr 29 2020 at 13:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859">said</a>:</p>
<blockquote>
<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">type</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">One</span> <span class="bp">|</span> <span class="n">Omega</span> <span class="bp">|</span> <span class="n">Prod</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span><span class="bp">|</span> <span class="n">Pow</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">Ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Omega</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="mi">𝟙</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">One</span>
<span class="kn">infix</span> <span class="bp">`××`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Prod</span>
<span class="kn">prefix</span> <span class="err">𝒫</span> <span class="o">:</span><span class="mi">101</span> <span class="o">:=</span> <span class="n">type</span><span class="bp">.</span><span class="n">Pow</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span>  <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Ω</span>
</code></pre></div>


<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>
<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>
</blockquote>



<a name="195709460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709460">(Apr 29 2020 at 13:37)</a>:</h4>
<p>Say the context is empty but you have a variable. Is that well-formed?</p>



<a name="195709467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709467">(Apr 29 2020 at 13:37)</a>:</h4>
<p>Ah sorry I just realised it was you I was discussing this with earlier. I'm not sure specifically what I should clarify more about <code>WF</code>, given the definition there</p>



<a name="195709613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709613">(Apr 29 2020 at 13:38)</a>:</h4>
<p>Inductively defined propositions:</p>
<ol>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">TPIL</a></li>
<li><a href="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226" title="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226">Codewars: Multiples of 3, you say?</a></li>
<li><a href="https://www.codewars.com/kata/5e59626530e9d00028bbe569" title="https://www.codewars.com/kata/5e59626530e9d00028bbe569">Codewars: Times Three, Plus Five</a></li>
</ol>



<a name="195709755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195709755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195709755">(Apr 29 2020 at 13:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Yeah I thought about that and I'm not sure how to fix that. For my use I think I can just allow those terms to exist?</p>



<a name="195710127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710127">(Apr 29 2020 at 13:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Even though I use the keyword <code>def</code>, I'm still defining it inductively on the inductive type <code>term A</code> right?</p>



<a name="195710205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710205">(Apr 29 2020 at 13:42)</a>:</h4>
<p>yes, but <code>inductive</code> might be better for this case</p>



<a name="195710496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710496">(Apr 29 2020 at 13:44)</a>:</h4>
<p>Hmm, is that because it allows me to name the axioms for well-formedness on each of the term A's? I'm not sure I see the difference/benefit.</p>



<a name="195710600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710600">(Apr 29 2020 at 13:45)</a>:</h4>
<p>it allows you to "inject" things</p>



<a name="195710631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710631">(Apr 29 2020 at 13:45)</a>:</h4>
<p>and you don't need to go through every case</p>



<a name="195710684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195710684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195710684">(Apr 29 2020 at 13:46)</a>:</h4>
<p>(cases you haven't gone through are automatically "false")</p>



<a name="195711420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195711420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195711420">(Apr 29 2020 at 13:50)</a>:</h4>
<p>I'm pretty sure Reid is hinting at this, but more directly: you don't want <code>∀ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>, you want <code>∃ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>. The former says that either the type is correct or it's out of range, while the latter says that it is in range and the type is correct. Better yet, skip the hypothesis and use <code>Γ.nth n = some A</code></p>



<a name="195711855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195711855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195711855">(Apr 29 2020 at 13:53)</a>:</h4>
<p>Beautiful, thank you.</p>



<a name="195713258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195713258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195713258">(Apr 29 2020 at 14:01)</a>:</h4>
<p>Here's what I've got now (it compiles). I'm still not understanding the suggestion to use <code>inductive</code>. </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">WF</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="n">A</span> <span class="bp">→</span> <span class="kn">context</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">A</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">comp</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∀</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span><span class="err">&#39;</span> <span class="n">A</span> <span class="n">φ</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="err">Ω</span> <span class="n">φ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Γ</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="err">⁎</span> <span class="err">Γ</span>          <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">top</span> <span class="err">Γ</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">bot</span> <span class="err">Γ</span>        <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">prod</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="err">Γ</span> <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">a</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">b</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">a</span> <span class="err">∈</span> <span class="n">α</span><span class="o">)</span> <span class="err">Γ</span>    <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">a</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">α</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span><span class="err">&#39;</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>   <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">p</span> <span class="err">⟹</span> <span class="n">q</span><span class="o">)</span> <span class="err">Γ</span>  <span class="o">:=</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">p</span> <span class="err">Γ</span> <span class="bp">∧</span> <span class="n">WF</span> <span class="bp">_</span> <span class="n">q</span> <span class="err">Γ</span>
</code></pre></div>



<a name="195715381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715381">(Apr 29 2020 at 14:13)</a>:</h4>
<p>Surely if I use inductive, I can only talking about creating un-named elements of <code>Prop</code>, and I can't actually define which proposition they are right?</p>



<a name="195715636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715636">(Apr 29 2020 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195709613" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195709613">said</a>:</p>
<blockquote>
<p>Inductively defined propositions:</p>
<ol>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions">TPIL</a></li>
<li><a href="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226" title="https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226">Codewars: Multiples of 3, you say?</a></li>
<li><a href="https://www.codewars.com/kata/5e59626530e9d00028bbe569" title="https://www.codewars.com/kata/5e59626530e9d00028bbe569">Codewars: Times Three, Plus Five</a></li>
</ol>
</blockquote>



<a name="195715726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195715726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195715726">(Apr 29 2020 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195710496" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195710496">said</a>:</p>
<blockquote>
<p>Hmm, is that because it allows me to name the axioms for well-formedness on each of the term A's? I'm not sure I see the difference/benefit.</p>
</blockquote>
<p>Benefits of an inductive type for well-formedness (or any similar predicate):</p>
<ul>
<li>You can do "rule induction", i.e. induction on the derivation of a well-formedness proof. If you define the predicate by recursion over terms instead, you can't directly eliminate a hypothesis <code>WF t</code>; you'll have to eliminate <code>t</code> first until the <code>WF</code> reduces. (In your case, there's little difference in this regard because the structure of your well-formedness predicate is very close to the structure of your terms.)</li>
<li>Recursive definitions must pass the termination checker; inductive definitions are generally more liberal. (Also not a concern in your case because you don't need a complicated recursive structure.)</li>
<li>Lean may make the recursive definition extra cumbersome to use because it's picky about reducing definitional equalities (though that might not be a problem in practice; I haven't experimented with this). Maybe mark the <code>WF</code> def as <code>@[reducible]</code>.</li>
</ul>
<p>Benefits of a recursive definition of well-formedness:</p>
<ul>
<li>It may be a little clearer what's going on I guess?</li>
</ul>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195715381" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195715381">said</a>:</p>
<blockquote>
<p>Surely if I use inductive, I can only talking about creating un-named elements of <code>Prop</code>, and I can't actually define which proposition they are right?</p>
</blockquote>
<p>Sorry, I don't understand your concern; could you rephrase?</p>



<a name="195717605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195717605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195717605">(Apr 29 2020 at 14:28)</a>:</h4>
<p>Hmm, I'm feeling pretty confused. I definitely need to go back an practice more basic lean.</p>



<a name="195718293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718293">(Apr 29 2020 at 14:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span>  thanks for the resource, I think I understand it in that context but I'm struggling to translate to my case.</p>



<a name="195718415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718415">(Apr 29 2020 at 14:33)</a>:</h4>
<p>Think of it in terms of what rules build up well-formed formulas into bigger ones, rather than how do you break down a formula to check whether it is well-formed.</p>



<a name="195718440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718440">(Apr 29 2020 at 14:33)</a>:</h4>
<p>Actually, it's exactly like an inductive type except it's a proposition.</p>



<a name="195718538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718538">(Apr 29 2020 at 14:34)</a>:</h4>
<p>Hmm - aren't I then just redefining <code>term A</code>?</p>



<a name="195718580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718580">(Apr 29 2020 at 14:34)</a>:</h4>
<p>Basically, yes</p>



<a name="195718676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718676">(Apr 29 2020 at 14:35)</a>:</h4>
<p>But you still have <code>term</code> also, so you aren't restricted to only ever considering well-formed terms</p>



<a name="195718760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718760">(Apr 29 2020 at 14:35)</a>:</h4>
<p>Also, in general, you might have a more interesting notion of well-formedness which isn't directly defined by recursion on the term, but I think that doesn't happen here.</p>



<a name="195718852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718852">(Apr 29 2020 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195564583" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195564583">said</a>:</p>
<blockquote>
<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>
</blockquote>
<p>This is the advice I am trying to follow at the moment</p>



<a name="195718913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195718913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195718913">(Apr 29 2020 at 14:36)</a>:</h4>
<p>Both your recursive function and an inductive well-formedness predicate fall into this category, I think.</p>



<a name="195719093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719093">(Apr 29 2020 at 14:37)</a>:</h4>
<p>I mean, your <code>WF</code> function also basically contains a complete definition of <code>term</code>, in the sense that all the constructors are listed</p>



<a name="195719203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719203">(Apr 29 2020 at 14:38)</a>:</h4>
<p>Good point</p>



<a name="195719474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195719474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195719474">(Apr 29 2020 at 14:40)</a>:</h4>
<p>So are you suggesting keeping the inductive term, and making an inductive WF with a context, or put the context into the term from the start so every term is well-formed (by forcing the binders and var to follow the context)?</p>



<a name="195720456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/195720456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#195720456">(Apr 29 2020 at 14:47)</a>:</h4>
<p>Those are two options. Another is the recursive <code>WF</code> function you already have.<br>
The recursive <code>WF</code> function and the inductive well-formedness predicate are basically equivalent in terms of what you can express easily. (The main difference is that the inductive predicate gives you the ability to induct on the proof of well-formedness, but here it looks basically equivalent to inducting on the term itself; the recursive function is more like an algorithm for computing whether something is well-formed and it lets you directly prove, for example, that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∧</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\varphi \wedge \psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span> is well-formed then the components <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span> are well-formed, which needs a case analysis if using the inductive predicate.)<br>
Putting the context into the term from the start is not really equivalent, since it means you only have the vocabulary to ever talk about well-formed terms.</p>



<a name="196264720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196264720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196264720">(May 05 2020 at 03:37)</a>:</h4>
<p>I'm going with the well-typed-from-the-start approach for now, and I've coming up with a <code>var</code> constructer which sandwiches a given type <code>A</code> between the context of terms of about to be bound <code>\Gamma</code> and those which will be bound after this variable, <code>\Delta</code>. To be clear, in any context, the type of the 0th de-bruijn index variable is at the head of the list-context.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="kn">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">type</span>

<span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">term</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">term</span> <span class="err">Γ</span> <span class="err">Ω</span>
</code></pre></div>


<p>As the terms currently exist, to construct a big term inductively from smaller terms, you need to know the whole context of the big term to construct and use the variables of the small terms. Obviously this is unsustainable, so I think I need to create a function for modifying contexts. I don't think there's many restrictions on the kind of context modification you can do, which includes adding more context to the end of the context, lifting the context and inserting other context before it, and also any reordering of types in the existing context. Perhaps there's some general pattern there, but I'm struggling to even define a simple case. If I mention <code>A</code> more than once between then <code>|</code> and the <code>:=</code>, it tells me <code>A already appears in this pattern</code>. I understand why that's an error, but I'm not sure what I'm supposed to do instead. I haven't been able to write the other cases for similar reasons.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add_junk</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">type</span><span class="o">),</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="n">β</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>



<a name="196293916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196293916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196293916">(May 05 2020 at 11:12)</a>:</h4>
<p>You should leave the first two arguments blank, they are inferred from the third</p>



<a name="196294018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196294018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196294018">(May 05 2020 at 11:14)</a>:</h4>
<p>Alternatively you should be able to put a dot before them like</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add_junk</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="kn">context</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">type</span><span class="o">),</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="n">β</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="bp">.</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="bp">.</span><span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
</code></pre></div>


<p>and it will mark those positions as "inacessible" meaning that it won't try to split on the first argument and figure out why <code>list.append Γ (A::Δ)</code> is a constructor (because it's not)</p>



<a name="196297051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196297051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196297051">(May 05 2020 at 11:51)</a>:</h4>
<p>That results in this error</p>
<div class="codehilite"><pre><span></span><code><span class="n">equation</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">var</span> <span class="err">Γ</span> <span class="n">A</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">)</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Δ</span> <span class="n">β</span><span class="o">))</span> <span class="n">A</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="bp">.</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span> <span class="bp">::</span> <span class="err">Δ</span><span class="o">))</span> <span class="n">β</span><span class="o">)</span> <span class="bp">.</span><span class="n">A</span>
</code></pre></div>



<a name="196297202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196297202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196297202">(May 05 2020 at 11:53)</a>:</h4>
<p>Also what is the . syntax called so I can find it in the documentation?</p>



<a name="196300768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300768">(May 05 2020 at 12:31)</a>:</h4>
<p>It's called an inaccessible pattern. It is almost never used in lean/mathlib because in basically every case you can use <code>_</code> instead</p>



<a name="196300838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300838">(May 05 2020 at 12:31)</a>:</h4>
<p>If you want to name the parameters, you should do so in the constructor <code>var Γ A Δ</code>, possibly using <code>@var more names Γ A Δ</code></p>



<a name="196300929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300929">(May 05 2020 at 12:32)</a>:</h4>
<p>Anyway, you've just hit DTT hell in that error there</p>



<a name="196300982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196300982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196300982">(May 05 2020 at 12:32)</a>:</h4>
<p>You should definitely not have this constructor</p>
<div class="codehilite"><pre><span></span><code><span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="n">A</span>
</code></pre></div>


<p>because the term will usually not have this form</p>



<a name="196301015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301015">(May 05 2020 at 12:33)</a>:</h4>
<p>Instead you can use <code>| var (Γ A) : A \in Γ -&gt; term Γ A</code></p>



<a name="196301127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301127">(May 05 2020 at 12:34)</a>:</h4>
<p>But then how can I possibly tell which type in the context list my var is constructing?</p>



<a name="196301141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301141">(May 05 2020 at 12:34)</a>:</h4>
<p>or <code>| var {Γ i A} : list.nth Γ i = some A -&gt; term Γ A</code></p>



<a name="196301170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301170">(May 05 2020 at 12:34)</a>:</h4>
<p>that one gives you a de bruijn index</p>



<a name="196301243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301243">(May 05 2020 at 12:35)</a>:</h4>
<p>Am I not achieving the same thing by stacking a context below and a context above <code>A</code> in <code>var \Gamma A \Delta</code>?</p>



<a name="196301302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301302">(May 05 2020 at 12:36)</a>:</h4>
<p>"the same thing" up to equality but not up to defeq</p>



<a name="196301338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301338">(May 05 2020 at 12:36)</a>:</h4>
<p>and the reason defeq is coming up is because you have a dependent type</p>



<a name="196301376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301376">(May 05 2020 at 12:37)</a>:</h4>
<p>defeq meaning definitional equality?</p>



<a name="196301387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301387">(May 05 2020 at 12:37)</a>:</h4>
<p><code>term (list.append Γ (A :: list.append Δ β)) A</code> and <code>term (list.append (list.append Γ (A :: Δ)) β) A</code> are distinct types, so you have to insert a cast between them and this will make everything harder</p>



<a name="196301478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301478">(May 05 2020 at 12:38)</a>:</h4>
<p>(this is the issue I was predicting when I originally recommended to use a weakly typed <code>term</code> syntax + a well formedness judgment)</p>



<a name="196301480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301480">(May 05 2020 at 12:38)</a>:</h4>
<p>ooh that's odd, I would have expected them to reduce to the same thing by unwrapping the definition of list.append?</p>



<a name="196301493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301493">(May 05 2020 at 12:38)</a>:</h4>
<p>You can't because <code>Γ</code> is a variable</p>



<a name="196301521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301521">(May 05 2020 at 12:39)</a>:</h4>
<p>For every concrete term for <code>Γ</code> these two are defeq, but for variable <code>Γ</code> you have to prove it by induction</p>



<a name="196301562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301562">(May 05 2020 at 12:39)</a>:</h4>
<p>that's pretty interesting</p>



<a name="196301632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301632">(May 05 2020 at 12:40)</a>:</h4>
<p>Obviously you should use a difference list for your context <em>flees</em></p>



<a name="196301805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301805">(May 05 2020 at 12:42)</a>:</h4>
<p>You might have seen before I was trying to go with your original suggestion, but was struggling  to define the well-formedness predicate and was kinda lead back into well-typing it from the start.</p>



<a name="196301876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301876">(May 05 2020 at 12:43)</a>:</h4>
<p>The well formedness predicate can be done with either <code>inductive</code> or <code>def</code>. <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195713258</a> &lt;- this looks okay</p>



<a name="196301920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196301920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196301920">(May 05 2020 at 12:43)</a>:</h4>
<p><code>inductive</code> gives you a bit more freedom to not be strictly recursive</p>



<a name="196302102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302102">(May 05 2020 at 12:45)</a>:</h4>
<p>it's also more natural when proving theorems by induction on well formed terms, so the sort of thing that the dependent type would give you</p>



<a name="196302198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302198">(May 05 2020 at 12:46)</a>:</h4>
<p>the <code>def</code> is what you would want for implementing a type checker, or a proof that the typing judgment is decidable</p>



<a name="196302262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302262">(May 05 2020 at 12:47)</a>:</h4>
<p>but you can have both versions and prove equivalence so there isn't a loss in picking one method over the other at first</p>



<a name="196302406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302406">(May 05 2020 at 12:48)</a>:</h4>
<p>I see the issues with using my non-defeq context-terms, but given your constructor<code> | var {Γ i A} : list.nth Γ i = some A -&gt; term Γ A</code>, would that suffer from similar issues?</p>



<a name="196302557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302557">(May 05 2020 at 12:49)</a>:</h4>
<p>that will solve the problem you have with unifying the context, because <code>var</code> can have any context, and the content is shifted to the hypothesis, which is a Prop and hence has no issues with defeq</p>



<a name="196302653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302653">(May 05 2020 at 12:50)</a>:</h4>
<p>your original <code>var</code> constructor only supports contexts of the form <code>Γ ++ A :: Δ</code></p>



<a name="196302878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196302878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196302878">(May 05 2020 at 12:52)</a>:</h4>
<p>Yep, but given that improvement, am I naive to think that fixes everything and using a WF predicate on weakly-typed terms is overly complicated?</p>



<a name="196303010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303010">(May 05 2020 at 12:54)</a>:</h4>
<p>With the inductive version you can set it up so that it looks almost the same. It's only about twice as long because you have two definitions instead of one (the terms, and the well formedness inductive type)</p>



<a name="196303088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303088">(May 05 2020 at 12:54)</a>:</h4>
<p>but feel free to continue with dependent types, I've hopefully unstuck you on that issue and there are fixes or workarounds for most of the other problems that will arise</p>



<a name="196303162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196303162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196303162">(May 05 2020 at 12:55)</a>:</h4>
<p>I really appreciate the help in getting me started.</p>



<a name="196304258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Modelling%20a%20Type%20Theory%20in%20Lean/near/196304258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean.html#196304258">(May 05 2020 at 13:04)</a>:</h4>
<p>Here's the inductive-ification of the <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/196264720" title="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/196264720">original dependent type</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">:</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>


<span class="kn">inductive</span> <span class="n">WF</span> <span class="o">:</span> <span class="kn">context</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="err">Γ</span> <span class="n">A</span> <span class="err">Δ</span><span class="o">)</span> <span class="o">:</span> <span class="n">WF</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Δ</span><span class="o">))</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">var</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="err">Γ</span><span class="o">))</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">comp</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">all</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">all</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">ex</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">,</span> <span class="n">WF</span> <span class="o">(</span><span class="n">A</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">e</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">all</span> <span class="n">A</span> <span class="n">e</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">star</span> <span class="mi">𝟙</span>
<span class="bp">|</span> <span class="n">top</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">top</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">bot</span>  <span class="o">{</span><span class="err">Γ</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">term</span><span class="bp">.</span><span class="n">bot</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">prod</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₂</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">prod</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">××</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">elem</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">type</span><span class="o">},</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₂</span> <span class="o">(</span><span class="err">𝒫</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">elem</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">and</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">and</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">or</span>   <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">or</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
<span class="bp">|</span> <span class="n">imp</span>  <span class="o">{</span><span class="err">Γ</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">}</span> <span class="o">:</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="n">e₁</span> <span class="err">Ω</span> <span class="bp">→</span> <span class="n">WF</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">term</span><span class="bp">.</span><span class="n">imp</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="err">Ω</span>
</code></pre></div>


<p>there is actually an algorithm to perform these sort of translations, although I took the liberty of using a nat for the variable and otherwise removing unnecessary arguments from <code>term</code>, which is not obvious to the straightforward algorithm.</p>



{% endraw %}

<hr><p>Last updated: May 05 2020 at 13:06 UTC</p>